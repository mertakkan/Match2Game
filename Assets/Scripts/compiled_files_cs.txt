================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Audio\AudioManager.cs
================================================================================

using UnityEngine;

public class AudioManager : MonoBehaviour
{
    private AudioSource audioSource;
    private GameConfig config;

    void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        if (audioSource == null)
        {
            audioSource = gameObject.AddComponent<AudioSource>();
        }
    }

    void Start()
    {
        config = GameManager.Instance.gameConfig;
    }

    public void PlayExplosionSound()
    {
        if (config != null && config.cubeExplodeSound != null)
        {
            audioSource.PlayOneShot(config.cubeExplodeSound);
        }
    }

    public void PlayCollectSound()
    {
        if (config != null && config.cubeCollectSound != null)
        {
            audioSource.PlayOneShot(config.cubeCollectSound);
        }
    }

    public void PlayBalloonSound()
    {
        if (config != null && config.balloonSound != null)
        {
            audioSource.PlayOneShot(config.balloonSound);
        }
    }

    public void PlayDuckSound()
    {
        if (config != null && config.duckSound != null)
        {
            audioSource.PlayOneShot(config.duckSound);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Config\GameConfig.cs
================================================================================

using UnityEngine;

[CreateAssetMenu(fileName = "GameConfig", menuName = "Match2Game/GameConfig")]
public class GameConfig : ScriptableObject
{
    [Header("Grid Settings")]
    public int gridWidth = 6;
    public int gridHeight = 8;
    public float cellSize = 1.0f;
    public float gridSpacing = 0.1f;

    [Header("Gameplay Settings")]
    public int movesPerLevel = 20;
    public int minMatchSize = 2;
    public int rocketTriggerSize = 5;

    [Header("Cube Settings")]
    public Sprite[] cubeSprites = new Sprite[5]; // Assign cube_1 to cube_5 sprites here

    [Header("Special Object Sprites")]
    public Sprite balloonSprite;
    public Sprite duckSprite;
    public Sprite rocketHorizontalSprite;
    public Sprite rocketVerticalSprite;

    [Header("UI Sprites")]
    public Sprite backgroundSprite;
    public Sprite topUISprite;
    public Sprite bottomUISprite;
    public Sprite bordersSprite;

    [Header("Particle Sprites")]
    public Sprite[] particleSprites = new Sprite[2]; // cubeParticle1 and cubeParticle2

    [Header("Level Goals")]
    public LevelGoal[] levelGoals;

    [Header("Animation Settings")]
    public float cubeFallSpeed = 5f;
    public float explosionDuration = 0.5f;
    public float rocketMoveSpeed = 10f;
    public float particleLifetime = 1f;

    [Header("Audio")]
    public AudioClip cubeExplodeSound;
    public AudioClip cubeCollectSound;
    public AudioClip balloonSound;
    public AudioClip duckSound;
}

[System.Serializable]
public class LevelGoal
{
    public int colorIndex;
    public int targetAmount;
    public int currentAmount;
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Core\GameManager.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{
    [Header("References")]
    public GameConfig gameConfig;
    public GridManager gridManager;
    public UIManager uiManager;
    public AudioManager audioManager;
    public EffectsManager effectsManager;

    [Header("Game State")]
    public int currentMoves;
    public bool gameActive = true;
    public List<LevelGoal> currentGoals;

    public static GameManager Instance { get; private set; }

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        // Find references if not assigned
        if (gridManager == null)
            gridManager = FindObjectOfType<GridManager>();
        if (uiManager == null)
            uiManager = FindObjectOfType<UIManager>();
        if (audioManager == null)
            audioManager = FindObjectOfType<AudioManager>();
        if (effectsManager == null)
            effectsManager = FindObjectOfType<EffectsManager>();

        InitializeGame();
    }

    void InitializeGame()
    {
        if (gameConfig == null)
        {
            gameConfig = Resources.Load<GameConfig>("GameConfig");
            if (gameConfig == null)
            {
                Debug.LogError("GameConfig not found in Resources folder!");
                return;
            }
        }

        currentMoves = gameConfig.movesPerLevel;
        currentGoals = new List<LevelGoal>();

        // Copy goals from config
        if (gameConfig.levelGoals != null)
        {
            foreach (var goal in gameConfig.levelGoals)
            {
                currentGoals.Add(
                    new LevelGoal
                    {
                        colorIndex = goal.colorIndex,
                        targetAmount = goal.targetAmount,
                        currentAmount = 0
                    }
                );
            }
        }

        if (gridManager != null)
            gridManager.InitializeGrid();
        else
            Debug.LogError("GridManager reference is missing!");

        if (uiManager != null)
            uiManager.UpdateUI();
        else
            Debug.LogError("UIManager reference is missing!");
    }

    public bool TryMakeMove()
    {
        if (!gameActive || currentMoves <= 0)
            return false;

        currentMoves--;
        uiManager.UpdateMoves(currentMoves);

        CheckGameEnd();
        return true;
    }

    public void CollectCube(int colorIndex, int amount = 1)
    {
        foreach (var goal in currentGoals)
        {
            if (goal.colorIndex == colorIndex)
            {
                goal.currentAmount = Mathf.Min(goal.currentAmount + amount, goal.targetAmount);
                uiManager.UpdateGoals(currentGoals);
                break;
            }
        }

        CheckWinCondition();
    }

    void CheckWinCondition()
    {
        bool allGoalsComplete = true;
        foreach (var goal in currentGoals)
        {
            if (goal.currentAmount < goal.targetAmount)
            {
                allGoalsComplete = false;
                break;
            }
        }

        if (allGoalsComplete)
        {
            gameActive = false;
            uiManager.ShowWinScreen();
        }
    }

    void CheckGameEnd()
    {
        if (currentMoves <= 0)
        {
            bool hasGoalsComplete = true;
            foreach (var goal in currentGoals)
            {
                if (goal.currentAmount < goal.targetAmount)
                {
                    hasGoalsComplete = false;
                    break;
                }
            }

            if (!hasGoalsComplete)
            {
                gameActive = false;
                uiManager.ShowLoseScreen();
            }
        }
    }

    public void RestartLevel()
    {
        gameActive = true;
        InitializeGame();
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Cubes\CubeController.cs
================================================================================

using UnityEngine;

public class CubeController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private Collider2D cubeCollider;

    public int ColorIndex { get; private set; }
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        cubeCollider = GetComponent<Collider2D>();
    }

    public void Initialize(int colorIndex, Sprite cubeSprite)
    {
        ColorIndex = colorIndex;
        spriteRenderer.sprite = cubeSprite;

        spriteRenderer.sortingLayerName = "Default";
        spriteRenderer.sortingOrder = 5;
        spriteRenderer.color = new Color(1f, 1f, 1f, 1f);
        spriteRenderer.enabled = true;

        if (spriteRenderer.material == null || spriteRenderer.material.name.Contains("Default"))
        {
            spriteRenderer.material = new Material(Shader.Find("Sprites/Default"));
        }

        // Ensure collider is enabled and properly sized
        if (cubeCollider != null)
        {
            cubeCollider.enabled = true;
            cubeCollider.isTrigger = false;

            if (cubeCollider is BoxCollider2D boxCollider)
            {
                boxCollider.size = Vector2.one;
            }
        }
    }

    public void SetGridPosition(Vector2Int position)
    {
        GridPosition = position;
        gameObject.name = $"Cube_{position.x}_{position.y}_{ColorIndex}";
    }

    void OnMouseDown()
    {
        // Add debug info
        Debug.Log($"Cube clicked: {gameObject.name} at grid position {GridPosition}");

        if (GridPosition.x >= 0 && GridPosition.y >= 0)
        {
            GridManager gridManager = FindObjectOfType<GridManager>();
            if (gridManager != null)
            {
                gridManager.HandleCubeClick(GridPosition.x, GridPosition.y);
            }
            else
            {
                Debug.LogError("GridManager not found!");
            }
        }
        else
        {
            Debug.LogError($"Invalid grid position: {GridPosition}");
        }
    }

    public void AnimateCollection(Vector3 targetPosition)
    {
        StartCoroutine(AnimateToTarget(targetPosition));
    }

    private System.Collections.IEnumerator AnimateToTarget(Vector3 target)
    {
        Vector3 startPos = transform.position;
        float duration = 0.8f;
        float elapsed = 0;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / duration;
            transform.position = Vector3.Lerp(startPos, target, t);
            yield return null;
        }

        Destroy(gameObject);
    }

    // Add this for debugging
    void OnMouseEnter()
    {
        // Optional: Add visual feedback when hovering
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1.2f, 1.2f, 1.2f, 1f);
        }
    }

    void OnMouseExit()
    {
        // Reset color
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1f, 1f, 1f, 1f);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Effects\EffectsManager.cs
================================================================================

using System.Collections;
using UnityEngine;

public class EffectsManager : MonoBehaviour
{
    [Header("Prefabs")]
    public GameObject particleSystemPrefab;

    private GameConfig config;

    void Start()
    {
        config = GameManager.Instance.gameConfig;
        CreateParticleSystemPrefab();
    }

    void CreateParticleSystemPrefab()
    {
        if (particleSystemPrefab == null && config.particleSprites.Length > 0)
        {
            // Create particle system prefab programmatically
            GameObject prefab = new GameObject("CubeExplosionParticle");
            ParticleSystem ps = prefab.AddComponent<ParticleSystem>();

            var main = ps.main;
            main.startLifetime = config.particleLifetime;
            main.startSpeed = 5f;
            main.startSize = 0.3f;
            main.startColor = Color.white;
            main.maxParticles = 15;
            main.simulationSpace = ParticleSystemSimulationSpace.World;

            var emission = ps.emission;
            emission.rateOverTime = 0;
            emission.SetBursts(new ParticleSystem.Burst[] { new ParticleSystem.Burst(0, 10) });

            var shape = ps.shape;
            shape.enabled = true;
            shape.shapeType = ParticleSystemShapeType.Circle;
            shape.radius = 0.3f;

            var velocityOverLifetime = ps.velocityOverLifetime;
            velocityOverLifetime.enabled = true;
            velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;
            velocityOverLifetime.radial = new ParticleSystem.MinMaxCurve(2f, 4f);

            // Set texture renderer with proper material
            var renderer = ps.GetComponent<ParticleSystemRenderer>();
            renderer.material = new Material(Shader.Find("Sprites/Default"));

            // Use the first particle sprite
            renderer.material.mainTexture = config.particleSprites[0].texture;
            renderer.sortingLayerName = "Default";
            renderer.sortingOrder = 10; // Above cubes

            particleSystemPrefab = prefab;
            particleSystemPrefab.SetActive(false); // Keep it inactive as prefab
        }
    }

    public void PlayExplosionEffect(Vector3 position, int colorIndex = 0)
    {
        if (particleSystemPrefab != null)
        {
            // Ensure position is valid and not NaN or infinity
            if (float.IsNaN(position.x) || float.IsNaN(position.y) || float.IsNaN(position.z))
            {
                Debug.LogWarning("Invalid particle position detected, skipping effect");
                return;
            }

            GameObject particle = Instantiate(particleSystemPrefab, position, Quaternion.identity);
            particle.SetActive(true);

            // Set particle color based on cube color
            ParticleSystem ps = particle.GetComponent<ParticleSystem>();
            if (ps != null)
            {
                var main = ps.main;

                // Get color from cube color index
                Color particleColor = GetColorFromIndex(colorIndex);
                main.startColor = particleColor;

                // Randomize particle sprite if we have multiple
                var renderer = ps.GetComponent<ParticleSystemRenderer>();
                if (config.particleSprites.Length > 1)
                {
                    int randomSpriteIndex = Random.Range(0, config.particleSprites.Length);
                    renderer.material.mainTexture = config
                        .particleSprites[randomSpriteIndex]
                        .texture;
                }

                // Play the particle system
                ps.Play();

                // Auto-destroy after particle lifetime
                StartCoroutine(DestroyAfterDelay(particle, config.particleLifetime + 0.5f));
            }
        }
        else
        {
            Debug.LogWarning("Particle system prefab is null!");
        }
    }

    Color GetColorFromIndex(int colorIndex)
    {
        // Map color indices to actual colors - you can customize these
        Color[] colors =
        {
            new Color(1f, 0.2f, 0.2f), // Red
            new Color(0.2f, 0.2f, 1f), // Blue
            new Color(0.2f, 1f, 0.2f), // Green
            new Color(1f, 1f, 0.2f), // Yellow
            new Color(1f, 0.2f, 1f) // Magenta
        };
        return colorIndex < colors.Length ? colors[colorIndex] : Color.white;
    }

    IEnumerator DestroyAfterDelay(GameObject obj, float delay)
    {
        yield return new WaitForSeconds(delay);
        if (obj != null)
        {
            Destroy(obj);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridCell.cs
================================================================================

using UnityEngine;

[System.Serializable]
public class GridCell
{
    public Vector2Int position;
    public CubeController cube;
    public RocketController rocket;

    public bool isEmpty => cube == null && rocket == null;
    public bool hasCube => cube != null;
    public bool hasRocket => rocket != null;

    public GridCell(int x, int y)
    {
        position = new Vector2Int(x, y);
        cube = null;
        rocket = null;
    }

    public void SetCube(CubeController newCube)
    {
        cube = newCube;
        rocket = null; // Clear rocket if placing cube
        if (cube != null)
        {
            cube.SetGridPosition(position);
        }
    }

    public void SetRocket(RocketController newRocket)
    {
        rocket = newRocket;
        cube = null; // Clear cube if placing rocket
        if (rocket != null)
        {
            rocket.SetGridPosition(position);
        }
    }

    public void ClearCube()
    {
        if (cube != null)
        {
            cube.SetGridPosition(new Vector2Int(-1, -1));
        }
        cube = null;
    }

    public void ClearRocket()
    {
        rocket = null;
    }

    public void Clear()
    {
        ClearCube();
        ClearRocket();
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridManager.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GridManager : MonoBehaviour
{
    [Header("Grid Setup")]
    public Transform gridParent;
    public GameObject cubePrefab;

    private GridCell[,] grid;
    private GameConfig config;
    private Camera mainCamera;
    private bool isProcessingMatches = false; // Prevent multiple simultaneous matches

    public int Width => config.gridWidth;
    public int Height => config.gridHeight;

    void Awake()
    {
        mainCamera = Camera.main;

        if (cubePrefab == null)
        {
            CreateCubePrefab();
        }
    }

    void CreateCubePrefab()
    {
        cubePrefab = new GameObject("CubePrefab");

        SpriteRenderer sr = cubePrefab.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 5;
        sr.color = new Color(1f, 1f, 1f, 1f);
        sr.material = new Material(Shader.Find("Sprites/Default"));

        BoxCollider2D collider = cubePrefab.AddComponent<BoxCollider2D>();
        collider.size = Vector2.one;

        cubePrefab.AddComponent<CubeController>();
        cubePrefab.SetActive(false);
        DontDestroyOnLoad(cubePrefab);
    }

    public void InitializeGrid()
    {
        config = GameManager.Instance.gameConfig;

        if (config == null)
        {
            Debug.LogError("GameConfig is null!");
            return;
        }

        // Clear existing grid
        if (gridParent != null)
        {
            foreach (Transform child in gridParent)
            {
                if (Application.isPlaying)
                    Destroy(child.gameObject);
                else
                    DestroyImmediate(child.gameObject);
            }
        }

        // Reset processing flag
        isProcessingMatches = false;

        grid = new GridCell[Width, Height];

        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                grid[x, y] = new GridCell(x, y);
            }
        }

        SetupCameraAndGrid();
        FillInitialGrid();
    }

    void SetupCameraAndGrid()
    {
        float totalWidth = Width * config.cellSize + (Width - 1) * config.gridSpacing;
        float totalHeight = Height * config.cellSize + (Height - 1) * config.gridSpacing;

        Vector3 gridOffset = new Vector3(
            -totalWidth * 0.5f + config.cellSize * 0.5f,
            -totalHeight * 0.5f + config.cellSize * 0.5f + 1f,
            0
        );

        if (gridParent != null)
        {
            gridParent.position = gridOffset;
        }

        float requiredSize = Mathf.Max(totalHeight * 0.8f, totalWidth * 0.6f / mainCamera.aspect);
        mainCamera.orthographicSize = requiredSize;
        mainCamera.transform.position = new Vector3(0, 1f, -10f);
    }

    void FillInitialGrid()
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                CreateRandomCube(x, y);
            }
        }
    }

    void CreateRandomCube(int x, int y)
    {
        if (cubePrefab == null || config.cubeSprites == null || config.cubeSprites.Length == 0)
        {
            Debug.LogError("Cannot create cube - missing prefab or sprites!");
            return;
        }

        GameObject cubeObj = Instantiate(cubePrefab, gridParent);
        cubeObj.SetActive(true);
        cubeObj.name = $"Cube_{x}_{y}";

        CubeController cube = cubeObj.GetComponent<CubeController>();
        if (cube == null)
        {
            Debug.LogError("CubePrefab doesn't have CubeController component!");
            return;
        }

        int randomColorIndex = Random.Range(0, config.cubeSprites.Length);
        cube.Initialize(randomColorIndex, config.cubeSprites[randomColorIndex]);

        Vector3 worldPos = GridToWorldPosition(x, y);
        cube.transform.position = worldPos;

        // CRITICAL: Set grid position and update grid reference
        cube.SetGridPosition(new Vector2Int(x, y));
        grid[x, y].SetCube(cube);
    }

    public Vector3 GridToWorldPosition(int x, int y)
    {
        float worldX = x * (config.cellSize + config.gridSpacing);
        float worldY = y * (config.cellSize + config.gridSpacing);
        return gridParent.position + new Vector3(worldX, worldY, 0);
    }

    public Vector2Int WorldToGridPosition(Vector3 worldPos)
    {
        Vector3 localPos = worldPos - gridParent.position;
        int x = Mathf.RoundToInt(localPos.x / (config.cellSize + config.gridSpacing));
        int y = Mathf.RoundToInt(localPos.y / (config.cellSize + config.gridSpacing));
        return new Vector2Int(x, y);
    }

    public GridCell GetCell(int x, int y)
    {
        if (x >= 0 && x < Width && y >= 0 && y < Height)
            return grid[x, y];
        return null;
    }

    public List<GridCell> FindMatches(int x, int y)
    {
        GridCell startCell = GetCell(x, y);
        if (startCell == null || !startCell.hasCube)
            return new List<GridCell>();

        List<GridCell> matches = new List<GridCell>();
        HashSet<Vector2Int> visited = new HashSet<Vector2Int>();

        FloodFillMatches(x, y, startCell.cube.ColorIndex, matches, visited);

        return matches.Count >= config.minMatchSize ? matches : new List<GridCell>();
    }

    void FloodFillMatches(
        int x,
        int y,
        int targetColor,
        List<GridCell> matches,
        HashSet<Vector2Int> visited
    )
    {
        if (visited.Contains(new Vector2Int(x, y)))
            return;

        GridCell cell = GetCell(x, y);
        if (cell == null || !cell.hasCube || cell.cube.ColorIndex != targetColor)
            return;

        visited.Add(new Vector2Int(x, y));
        matches.Add(cell);

        FloodFillMatches(x + 1, y, targetColor, matches, visited);
        FloodFillMatches(x - 1, y, targetColor, matches, visited);
        FloodFillMatches(x, y + 1, targetColor, matches, visited);
        FloodFillMatches(x, y - 1, targetColor, matches, visited);
    }

    public void HandleCubeClick(int x, int y)
    {
        if (!GameManager.Instance.gameActive || isProcessingMatches)
        {
            Debug.Log(
                $"Click ignored - Game active: {GameManager.Instance.gameActive}, Processing: {isProcessingMatches}"
            );
            return;
        }

        GridCell clickedCell = GetCell(x, y);
        if (clickedCell == null)
            return;

        // Handle rocket click
        if (clickedCell.hasRocket)
        {
            if (GameManager.Instance.TryMakeMove())
            {
                StartCoroutine(ProcessRocketActivation(clickedCell));
            }
            return;
        }

        // Handle cube click
        if (clickedCell.hasCube)
        {
            List<GridCell> matches = FindMatches(x, y);
            if (matches.Count > 0)
            {
                if (GameManager.Instance.TryMakeMove())
                {
                    StartCoroutine(ProcessMatches(matches, new Vector2Int(x, y)));
                }
            }
        }
    }

    private IEnumerator ProcessRocketActivation(GridCell rocketCell)
    {
        isProcessingMatches = true;

        RocketController rocket = rocketCell.rocket;
        Vector2Int rocketGridPos = rocket.GridPosition;

        // Clear the rocket from the grid model immediately
        rocketCell.ClearRocket();

        List<Vector2Int> destroyPositions = new List<Vector2Int>();

        // Determine which cubes to destroy based on rocket direction
        if (rocket.direction == RocketController.RocketDirection.Horizontal)
        {
            for (int x = 0; x < Width; x++)
            {
                destroyPositions.Add(new Vector2Int(x, rocketGridPos.y));
            }
        }
        else // Vertical
        {
            for (int y = 0; y < Height; y++)
            {
                destroyPositions.Add(new Vector2Int(rocketGridPos.x, y));
            }
        }

        // Destroy the rocket GameObject itself
        GameManager.Instance.effectsManager.PlayExplosionEffect(rocket.transform.position);
        Destroy(rocket.gameObject);

        // Destroy cubes and collect them
        foreach (Vector2Int pos in destroyPositions)
        {
            GridCell cell = GetCell(pos.x, pos.y);
            if (cell != null && cell.hasCube)
            {
                GameManager.Instance.CollectCube(cell.cube.ColorIndex, 1);
                GameManager.Instance.effectsManager.PlayExplosionEffect(
                    cell.cube.transform.position,
                    cell.cube.ColorIndex
                );
                Destroy(cell.cube.gameObject);
                cell.ClearCube();
            }
        }

        GameManager.Instance.audioManager.PlayExplosionSound();

        // Wait for visual destruction to be perceived
        yield return new WaitForSeconds(
            config.explosionDuration > 0.2f ? config.explosionDuration : 0.2f
        );

        // Now, run the standard grid update sequence
        yield return StartCoroutine(ApplyGravity());
        yield return StartCoroutine(FillEmptySpaces());
        UpdateAllCubePositions();

        isProcessingMatches = false;
        Debug.Log("Rocket activation processing complete.");
    }

    IEnumerator ProcessMatches(List<GridCell> matches, Vector2Int clickPosition)
    {
        isProcessingMatches = true;

        int colorIndex = matches[0].cube.ColorIndex;
        GameManager.Instance.CollectCube(colorIndex, matches.Count);

        bool shouldCreateRocket = matches.Count >= config.rocketTriggerSize;

        // Store rocket position before destroying cubes
        Vector3 rocketWorldPosition = GridToWorldPosition(clickPosition.x, clickPosition.y);

        // Explode cubes with effects
        foreach (var cell in matches)
        {
            if (cell.cube != null)
            {
                Vector3 explosionPosition = cell.cube.transform.position;

                if (!float.IsNaN(explosionPosition.x) && !float.IsNaN(explosionPosition.y))
                {
                    GameManager.Instance.effectsManager.PlayExplosionEffect(
                        explosionPosition,
                        cell.cube.ColorIndex
                    );
                }

                Destroy(cell.cube.gameObject);
                cell.ClearCube();
            }
        }

        GameManager.Instance.audioManager.PlayExplosionSound();

        yield return new WaitForSeconds(config.explosionDuration);

        // Create rocket AFTER clearing the cell but BEFORE gravity
        if (shouldCreateRocket)
        {
            CreateRocket(clickPosition, rocketWorldPosition);
        }

        // Apply gravity and fill grid
        yield return StartCoroutine(ApplyGravity());
        yield return StartCoroutine(FillEmptySpaces());

        // CRITICAL: Update all cube positions after movement
        UpdateAllCubePositions();

        isProcessingMatches = false;
    }

    void CreateRocket(Vector2Int gridPosition, Vector3 worldPosition)
    {
        RocketController.RocketDirection direction =
            Random.Range(0, 2) == 0
                ? RocketController.RocketDirection.Horizontal
                : RocketController.RocketDirection.Vertical;

        GameObject rocketObj = new GameObject("Rocket");
        rocketObj.transform.SetParent(gridParent);

        SpriteRenderer sr = rocketObj.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 6; // Above cubes

        BoxCollider2D col = rocketObj.AddComponent<BoxCollider2D>();
        col.size = Vector2.one;

        RocketController rocket = rocketObj.AddComponent<RocketController>();
        rocket.Initialize(direction, gridPosition);

        // Position rocket at the exact world position
        rocketObj.transform.position = worldPosition;

        // CRITICAL: Place rocket in grid system
        GridCell cell = GetCell(gridPosition.x, gridPosition.y);
        if (cell != null)
        {
            cell.SetRocket(rocket);
        }

        Debug.Log($"Created {direction} rocket at grid {gridPosition}, world {worldPosition}");
    }

    // CRITICAL: This method ensures all cubes have correct grid positions
    void UpdateAllCubePositions()
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                GridCell cell = grid[x, y];

                if (cell.hasCube && cell.cube != null)
                {
                    cell.cube.SetGridPosition(new Vector2Int(x, y));
                    Vector3 correctPosition = GridToWorldPosition(x, y);
                    cell.cube.transform.position = correctPosition;
                }

                if (cell.hasRocket && cell.rocket != null)
                {
                    cell.rocket.SetGridPosition(new Vector2Int(x, y));
                    Vector3 correctPosition = GridToWorldPosition(x, y);
                    cell.rocket.transform.position = correctPosition;
                }
            }
        }
        Debug.Log("Updated all cube and rocket positions");
    }

    IEnumerator ApplyGravity()
    {
        bool cubesMoved = true;

        while (cubesMoved)
        {
            cubesMoved = false;

            for (int x = 0; x < Width; x++)
            {
                for (int y = 0; y < Height - 1; y++)
                {
                    GridCell currentCell = grid[x, y];
                    // Skip if cell has a rocket
                    if (!currentCell.isEmpty || currentCell.hasRocket)
                        continue;

                    // Find cube above to fall down
                    for (int yAbove = y + 1; yAbove < Height; yAbove++)
                    {
                        GridCell aboveCell = grid[x, yAbove];
                        if (aboveCell.hasCube)
                        {
                            // Move cube down
                            currentCell.SetCube(aboveCell.cube);
                            aboveCell.ClearCube();

                            // Animate cube falling
                            if (currentCell.cube != null)
                            {
                                StartCoroutine(
                                    AnimateCubeFall(currentCell.cube, GridToWorldPosition(x, y))
                                );
                            }

                            cubesMoved = true;
                            break;
                        }
                    }
                }
            }

            if (cubesMoved)
            {
                yield return new WaitForSeconds(0.1f);
            }
        }
    }

    IEnumerator FillEmptySpaces()
    {
        // Fill from top to bottom
        for (int x = 0; x < Width; x++)
        {
            for (int y = Height - 1; y >= 0; y--)
            {
                GridCell cell = grid[x, y];
                // Only fill if cell is completely empty (no cube AND no rocket)
                if (cell.isEmpty)
                {
                    CreateRandomCube(x, y);

                    // Animate new cube falling from above
                    if (cell.hasCube && cell.cube != null)
                    {
                        Vector3 startPos = GridToWorldPosition(x, Height);
                        Vector3 endPos = GridToWorldPosition(x, y);
                        cell.cube.transform.position = startPos;
                        StartCoroutine(AnimateCubeFall(cell.cube, endPos));
                    }
                }
            }
        }

        yield return new WaitForSeconds(config.cubeFallSpeed / 5f);
    }

    IEnumerator AnimateCubeFall(CubeController cube, Vector3 targetPosition)
    {
        if (cube == null)
            yield break;

        Vector3 startPosition = cube.transform.position;
        float journey = 0f;
        float speed = config.cubeFallSpeed;

        while (journey <= 1f && cube != null)
        {
            journey += Time.deltaTime * speed;
            cube.transform.position = Vector3.Lerp(startPosition, targetPosition, journey);
            yield return null;
        }

        if (cube != null)
        {
            cube.transform.position = targetPosition;
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridPosition.cs
================================================================================

[System.Serializable]
public struct GridPosition
{
    public int x;
    public int y;

    public GridPosition(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static GridPosition operator +(GridPosition a, GridPosition b)
    {
        return new GridPosition(a.x + b.x, a.y + b.y);
    }

    public static bool operator ==(GridPosition a, GridPosition b)
    {
        return a.x == b.x && a.y == b.y;
    }

    public static bool operator !=(GridPosition a, GridPosition b)
    {
        return !(a == b);
    }

    public override bool Equals(object obj)
    {
        if (obj is GridPosition)
            return this == (GridPosition)obj;
        return false;
    }

    public override int GetHashCode()
    {
        return x.GetHashCode() ^ y.GetHashCode();
    }

    // Get adjacent positions (up, down, left, right)
    public GridPosition[] GetAdjacent()
    {
        return new GridPosition[]
        {
            new GridPosition(x, y + 1), // Up
            new GridPosition(x, y - 1), // Down
            new GridPosition(x - 1, y), // Left
            new GridPosition(x + 1, y) // Right
        };
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\BalloonController.cs
================================================================================

using UnityEngine;

public class BalloonController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private GridManager gridManager;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        gridManager = FindObjectOfType<GridManager>();
    }

    public void Initialize(Vector2Int gridPos)
    {
        GridPosition = gridPos;
        spriteRenderer.sprite = GameManager.Instance.gameConfig.balloonSprite;
        transform.position = gridManager.GridToWorldPosition(gridPos.x, gridPos.y);
    }

    public void ExplodeBalloon()
    {
        // Play balloon sound and effects
        GameManager.Instance.audioManager.PlayBalloonSound();
        GameManager.Instance.effectsManager.PlayExplosionEffect(transform.position);

        // Remove from grid if needed
        GridCell cell = gridManager.GetCell(GridPosition.x, GridPosition.y);
        if (cell != null)
        {
            // If balloon counts as goal, collect it
            // GameManager.Instance.CollectBalloon();
        }

        Destroy(gameObject);
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\DuckController.cs
================================================================================

using UnityEngine;

public class DuckController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private GridManager gridManager;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        gridManager = FindObjectOfType<GridManager>();
    }

    public void Initialize(Vector2Int gridPos)
    {
        GridPosition = gridPos;
        spriteRenderer.sprite = GameManager.Instance.gameConfig.duckSprite;
        transform.position = gridManager.GridToWorldPosition(gridPos.x, gridPos.y);
    }

    public void CheckIfAtBottom()
    {
        if (GridPosition.y == 0) // Bottom row
        {
            CollectDuck();
        }
    }

    void CollectDuck()
    {
        // Play duck sound and collection effects
        GameManager.Instance.audioManager.PlayDuckSound();

        // Collect for goals if applicable
        // GameManager.Instance.CollectDuck();

        Destroy(gameObject);
    }

    public void UpdateGridPosition(Vector2Int newPos)
    {
        GridPosition = newPos;
        CheckIfAtBottom();
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\RocketController.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RocketController : MonoBehaviour
{
    public enum RocketDirection
    {
        Horizontal,
        Vertical
    }

    [Header("Rocket Settings")]
    public RocketDirection direction;

    private SpriteRenderer spriteRenderer;
    private Collider2D rocketCollider;
    private GridManager gridManager;
    private GameConfig config;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        rocketCollider = GetComponent<Collider2D>();
        gridManager = FindObjectOfType<GridManager>();
        config = GameManager.Instance.gameConfig;
    }

    public void Initialize(RocketDirection dir, Vector2Int gridPos)
    {
        direction = dir;
        GridPosition = gridPos;

        // Set appropriate sprite
        if (direction == RocketDirection.Horizontal)
        {
            spriteRenderer.sprite = config.rocketHorizontalSprite;
        }
        else
        {
            spriteRenderer.sprite = config.rocketVerticalSprite;
        }

        // Set proper sorting and rendering
        spriteRenderer.sortingLayerName = "Default";
        spriteRenderer.sortingOrder = 6; // Above cubes
        spriteRenderer.color = Color.white;

        // Ensure collider is properly set up
        if (rocketCollider != null)
        {
            rocketCollider.enabled = true;
            rocketCollider.isTrigger = false;

            if (rocketCollider is BoxCollider2D boxCollider)
            {
                boxCollider.size = Vector2.one;
            }
        }

        gameObject.name = $"Rocket_{direction}_{gridPos.x}_{gridPos.y}";

        Debug.Log($"Rocket initialized: {direction} at {gridPos}");
    }

    public void SetGridPosition(Vector2Int position)
    {
        GridPosition = position;
    }

    void OnMouseDown()
    {
        Debug.Log($"Rocket clicked: {gameObject.name} at {GridPosition}");

        if (gridManager != null)
        {
            // Delegate click handling to the central GridManager
            gridManager.HandleCubeClick(GridPosition.x, GridPosition.y);
        }
    }

    // Visual feedback on hover
    void OnMouseEnter()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1.2f, 1.2f, 1.2f, 1f);
        }
    }

    void OnMouseExit()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = Color.white;
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\UI\GoalUIItem.cs
================================================================================

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class GoalUIItem : MonoBehaviour
{
    [Header("UI References")]
    public Image goalIcon;
    public TextMeshProUGUI goalTextTMP; // Using TextMeshPro

    private LevelGoal currentGoal;

    // Initialize the goal item with the starting target amount
    public void Initialize(LevelGoal goal, Sprite cubeSprite)
    {
        currentGoal = new LevelGoal
        {
            colorIndex = goal.colorIndex,
            targetAmount = goal.targetAmount,
            currentAmount = 0
        };

        if (goalIcon)
            goalIcon.sprite = cubeSprite;

        UpdateDisplay();
    }

    // This is called by UIManager whenever a cube is collected
    public void UpdateGoal(LevelGoal goal)
    {
        int oldAmount = currentGoal != null ? currentGoal.currentAmount : 0;
        currentGoal = goal; // Update the internal goal state
        UpdateDisplay();

        // Animate only when progress is made
        if (goal.currentAmount > oldAmount)
        {
            AnimateGoalCollection();
        }
    }

    // REWORKED: This method now displays the remaining amount
    void UpdateDisplay()
    {
        if (currentGoal == null)
            return;

        // Calculate the remaining amount needed
        int remainingAmount = currentGoal.targetAmount - currentGoal.currentAmount;
        if (remainingAmount < 0)
            remainingAmount = 0; // Prevent negative numbers

        // Update the text to show only the remaining amount
        if (goalTextTMP != null)
        {
            goalTextTMP.text = remainingAmount.ToString();
        }

        // If the goal is complete, you could add extra feedback,
        // like hiding the text or showing a checkmark.
        if (remainingAmount <= 0)
        {
            // For example, hide the text when the goal is met.
            goalTextTMP.gameObject.SetActive(false);
            // Optionally, change the icon to be grayed out
            if (goalIcon)
                goalIcon.color = Color.gray;
        }
    }

    void AnimateGoalCollection()
    {
        // Simple scale animation to give feedback
        StartCoroutine(ScaleAnimation());
    }

    System.Collections.IEnumerator ScaleAnimation()
    {
        Vector3 originalScale = transform.localScale;
        Vector3 targetScale = originalScale * 1.2f;
        float duration = 0.1f;

        // Scale up
        for (float t = 0; t < 1; t += Time.deltaTime / duration)
        {
            transform.localScale = Vector3.Lerp(originalScale, targetScale, t);
            yield return null;
        }

        // Scale down
        for (float t = 0; t < 1; t += Time.deltaTime / duration)
        {
            transform.localScale = Vector3.Lerp(targetScale, originalScale, t);
            yield return null;
        }

        transform.localScale = originalScale;
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\UI\UIManager.cs
================================================================================

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIManager : MonoBehaviour
{
    [Header("UI References")]
    public TextMeshProUGUI movesTextTMP;
    public Transform goalsContainer;
    public GameObject winPanel;
    public GameObject losePanel;
    public Button restartButton;

    [Header("Font Settings")]
    public Font defaultFont;

    private List<GoalUIItem> goalUIItems = new List<GoalUIItem>();
    private GameConfig config;

    void Start()
    {
        config = GameManager.Instance.gameConfig;

        if (defaultFont == null)
        {
            defaultFont = Resources.GetBuiltinResource<Font>("Arial.ttf");
        }

        if (winPanel)
            winPanel.SetActive(false);
        if (losePanel)
            losePanel.SetActive(false);

        SetupMovesText();
        SetupGoalUI();
        SetupPanels();
    }

    void SetupMovesText()
    {
        if (movesTextTMP != null)
        {
            RectTransform movesRect = movesTextTMP.GetComponent<RectTransform>();

            movesRect.anchorMin = new Vector2(1, 1);
            movesRect.anchorMax = new Vector2(1, 1);
            movesRect.pivot = new Vector2(1, 1);
            movesRect.anchoredPosition = new Vector2(-60, -60);
            movesRect.sizeDelta = new Vector2(150, 100);

            movesTextTMP.text = "" + GameManager.Instance.currentMoves;
            movesTextTMP.fontSize = 90;
            movesTextTMP.color = new Color32(198, 68, 60, 255);
            movesTextTMP.alignment = TextAlignmentOptions.Center;
            movesTextTMP.fontStyle = FontStyles.Bold;
            movesTextTMP.outlineWidth = 0.25f;
            movesTextTMP.outlineColor = new Color32(255, 243, 224, 255);
        }
    }

    void SetupGoalUI()
    {
        RectTransform goalsRect = goalsContainer.GetComponent<RectTransform>();
        if (goalsRect != null)
        {
            goalsRect.anchorMin = new Vector2(0.5f, 1);
            goalsRect.anchorMax = new Vector2(0.5f, 1);
            goalsRect.pivot = new Vector2(0.5f, 1);
            goalsRect.anchoredPosition = new Vector2(25, -55);
            goalsRect.sizeDelta = new Vector2(350, 120);
        }

        foreach (Transform child in goalsContainer)
        {
            Destroy(child.gameObject);
        }
        goalUIItems.Clear();

        HorizontalLayoutGroup layoutGroup = goalsContainer.GetComponent<HorizontalLayoutGroup>();
        if (layoutGroup == null)
        {
            layoutGroup = goalsContainer.gameObject.AddComponent<HorizontalLayoutGroup>();
        }

        layoutGroup.childAlignment = TextAnchor.MiddleCenter;
        layoutGroup.spacing = 15;
        layoutGroup.padding = new RectOffset(10, 10, 10, 10);
        layoutGroup.childControlWidth = false;
        layoutGroup.childControlHeight = false;

        foreach (var goal in config.levelGoals)
        {
            GameObject goalItemObj = CreateGoalItem(goal);
            goalUIItems.Add(goalItemObj.GetComponent<GoalUIItem>());
        }
    }

    // REWORKED: This function now positions the text to the bottom-right.
    GameObject CreateGoalItem(LevelGoal goal)
    {
        GameObject goalItem = new GameObject($"GoalItem_{goal.colorIndex}");
        goalItem.transform.SetParent(goalsContainer, false);
        goalItem.AddComponent<RectTransform>().sizeDelta = new Vector2(110, 110);

        GameObject iconObj = new GameObject("Icon");
        iconObj.transform.SetParent(goalItem.transform, false);
        Image iconImage = iconObj.AddComponent<Image>();
        iconImage.sprite = config.cubeSprites[goal.colorIndex];
        iconImage.rectTransform.sizeDelta = new Vector2(110, 110); // Make icon fill the space
        iconImage.rectTransform.anchoredPosition = Vector2.zero;

        GameObject textObj = new GameObject("Text (TMP)");
        textObj.transform.SetParent(goalItem.transform, false);
        TextMeshProUGUI tmpText = textObj.AddComponent<TextMeshProUGUI>();

        // Set the initial text to be the total target amount
        tmpText.text = goal.targetAmount.ToString();
        tmpText.fontSize = 52;
        tmpText.color = new Color32(0, 0, 0, 255);
        tmpText.fontStyle = FontStyles.Bold;
        tmpText.outlineWidth = 0.2f;
        tmpText.outlineColor = new Color32(255, 243, 224, 255);

        // --- POSITIONING & ALIGNMENT CHANGES ---
        RectTransform textRect = textObj.GetComponent<RectTransform>();

        // Anchor and pivot to the bottom-right of the parent (the icon)
        textRect.anchorMin = new Vector2(1, 0);
        textRect.anchorMax = new Vector2(1, 0);
        textRect.pivot = new Vector2(1, 0);

        // Set the size of the text box
        textRect.sizeDelta = new Vector2(80, 50);

        // Position with padding from the corner
        textRect.anchoredPosition = new Vector2(-5, 5);

        // Align the text itself to the center of its own box for a clean look
        tmpText.alignment = TextAlignmentOptions.Center;

        // --- END OF CHANGES ---

        GoalUIItem goalUIComponent = goalItem.AddComponent<GoalUIItem>();
        goalUIComponent.goalIcon = iconImage;
        goalUIComponent.goalTextTMP = tmpText;
        goalUIComponent.Initialize(goal, config.cubeSprites[goal.colorIndex]);

        return goalItem;
    }

    void SetupPanels()
    {
        if (restartButton != null)
        {
            restartButton.onClick.RemoveAllListeners();
            restartButton.onClick.AddListener(RestartGame);
        }
        else if (winPanel != null && losePanel != null)
        {
            Button winRestartButton = winPanel.GetComponentInChildren<Button>();
            if (winRestartButton)
                winRestartButton.onClick.AddListener(RestartGame);

            Button loseRestartButton = losePanel.GetComponentInChildren<Button>();
            if (loseRestartButton)
                loseRestartButton.onClick.AddListener(RestartGame);
        }
    }

    public void UpdateUI()
    {
        UpdateMoves(GameManager.Instance.currentMoves);
        UpdateGoals(GameManager.Instance.currentGoals);
    }

    public void UpdateMoves(int moves)
    {
        if (movesTextTMP != null)
            movesTextTMP.text = moves.ToString();
    }

    public void UpdateGoals(List<LevelGoal> goals)
    {
        for (int i = 0; i < goalUIItems.Count && i < goals.Count; i++)
        {
            goalUIItems[i].UpdateGoal(goals[i]);
        }
    }

    public void ShowWinScreen()
    {
        if (winPanel)
            winPanel.SetActive(true);
    }

    public void ShowLoseScreen()
    {
        if (losePanel)
            losePanel.SetActive(true);
    }

    public void HideGameOverPanels()
    {
        if (winPanel)
            winPanel.SetActive(false);
        if (losePanel)
            losePanel.SetActive(false);
    }

    void RestartGame()
    {
        GameManager.Instance.RestartLevel();
        HideGameOverPanels();
    }
}


