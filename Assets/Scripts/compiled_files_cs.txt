================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Audio\AudioManager.cs
================================================================================

using UnityEngine;

public class AudioManager : MonoBehaviour
{
    private AudioSource audioSource;
    private GameConfig config;

    void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        if (audioSource == null)
        {
            audioSource = gameObject.AddComponent<AudioSource>();
        }
    }

    void Start()
    {
        config = GameManager.Instance.gameConfig;
    }

    public void PlayExplosionSound()
    {
        if (config != null && config.cubeExplodeSound != null)
        {
            audioSource.PlayOneShot(config.cubeExplodeSound);
        }
    }

    public void PlayCollectSound()
    {
        if (config != null && config.cubeCollectSound != null)
        {
            audioSource.PlayOneShot(config.cubeCollectSound);
        }
    }

    public void PlayBalloonSound()
    {
        if (config != null && config.balloonSound != null)
        {
            audioSource.PlayOneShot(config.balloonSound);
        }
    }

    public void PlayDuckSound()
    {
        if (config != null && config.duckSound != null)
        {
            audioSource.PlayOneShot(config.duckSound);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Config\GameConfig.cs
================================================================================

using UnityEngine;

public enum GoalType
{
    Cube,
    Balloon,
    Duck
}

[CreateAssetMenu(fileName = "GameConfig", menuName = "Match2Game/GameConfig")]
public class GameConfig : ScriptableObject
{
    [Header("Grid Settings")]
    public int gridWidth = 6;
    public int gridHeight = 8;
    public float cellSize = 1.0f;
    public float gridSpacing = 0.1f;

    [Header("Gameplay Settings")]
    public int movesPerLevel = 20;
    public int minMatchSize = 2;
    public int rocketTriggerSize = 5;

    public int ducksInLevel = 0;

    public int balloonsInLevel = 0;

    [Header("Cube Settings")]
    public Sprite[] cubeSprites = new Sprite[5];

    [Header("Special Object Sprites")]
    public Sprite balloonSprite;
    public Sprite duckSprite;
    public Sprite rocketHorizontalSprite;
    public Sprite rocketVerticalSprite;

    [Header("UI Sprites")]
    public Sprite backgroundSprite;
    public Sprite topUISprite;
    public Sprite bottomUISprite;
    public Sprite bordersSprite;

    [Header("Particle Sprites")]
    public Sprite[] particleSprites = new Sprite[2];

    [Header("Level Goals")]
    public LevelGoal[] levelGoals;

    [Header("Animation Settings")]
    public float cubeFallSpeed = 5f;
    public float explosionDuration = 0.5f;
    public float rocketMoveSpeed = 10f;
    public float particleLifetime = 1f;

    [Header("Audio")]
    public AudioClip cubeExplodeSound;
    public AudioClip cubeCollectSound;
    public AudioClip balloonSound;
    public AudioClip duckSound;
}

[System.Serializable]
public class LevelGoal
{
    public GoalType goalType;

    public int colorIndex;
    public int targetAmount;
    public int currentAmount;
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Core\GameManager.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{
    [Header("References")]
    public GameConfig gameConfig;
    public GridManager gridManager;
    public UIManager uiManager;
    public AudioManager audioManager;
    public EffectsManager effectsManager;

    [Header("Game State")]
    public int currentMoves;
    public bool gameActive = true;
    public List<LevelGoal> currentGoals;

    public static GameManager Instance { get; private set; }

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if (gridManager == null)
            gridManager = FindObjectOfType<GridManager>();
        if (uiManager == null)
            uiManager = FindObjectOfType<UIManager>();
        if (audioManager == null)
            audioManager = FindObjectOfType<AudioManager>();
        if (effectsManager == null)
            effectsManager = FindObjectOfType<EffectsManager>();

        InitializeGame();
    }

    void InitializeGame()
    {
        if (gameConfig == null)
        {
            gameConfig = Resources.Load<GameConfig>("GameConfig");
            if (gameConfig == null)
            {
                Debug.LogError("GameConfig not found in Resources folder!");
                return;
            }
        }

        currentMoves = gameConfig.movesPerLevel;
        currentGoals = new List<LevelGoal>();

        if (gameConfig.levelGoals != null)
        {
            foreach (var goal in gameConfig.levelGoals)
            {
                currentGoals.Add(
                    new LevelGoal
                    {
                        goalType = goal.goalType,
                        colorIndex = goal.colorIndex,
                        targetAmount = goal.targetAmount,
                        currentAmount = 0
                    }
                );
            }
        }

        if (gridManager != null)
            gridManager.InitializeGrid();
        else
            Debug.LogError("GridManager reference is missing!");

        if (uiManager != null)
            uiManager.UpdateUI();
        else
            Debug.LogError("UIManager reference is missing!");
    }

    public bool TryMakeMove()
    {
        if (!gameActive || currentMoves <= 0)
            return false;

        currentMoves--;
        uiManager.UpdateMoves(currentMoves);

        CheckGameEnd();
        return true;
    }

    public void CollectCube(int colorIndex, int amount = 1)
    {
        foreach (var goal in currentGoals)
        {
            if (goal.goalType == GoalType.Cube && goal.colorIndex == colorIndex)
            {
                goal.currentAmount = Mathf.Min(goal.currentAmount + amount, goal.targetAmount);
                uiManager.UpdateGoals(currentGoals);
                break;
            }
        }
        CheckWinCondition();
    }

    public void CollectDuck(int amount = 1)
    {
        foreach (var goal in currentGoals)
        {
            if (goal.goalType == GoalType.Duck)
            {
                goal.currentAmount = Mathf.Min(goal.currentAmount + amount, goal.targetAmount);
                uiManager.UpdateGoals(currentGoals);
                break;
            }
        }
        CheckWinCondition();
    }

    public void CollectBalloon(int amount = 1)
    {
        foreach (var goal in currentGoals)
        {
            if (goal.goalType == GoalType.Balloon)
            {
                goal.currentAmount = Mathf.Min(goal.currentAmount + amount, goal.targetAmount);
                uiManager.UpdateGoals(currentGoals);
                break;
            }
        }
        CheckWinCondition();
    }

    void CheckWinCondition()
    {
        bool allGoalsComplete = true;
        foreach (var goal in currentGoals)
        {
            if (goal.currentAmount < goal.targetAmount)
            {
                allGoalsComplete = false;
                break;
            }
        }

        if (allGoalsComplete)
        {
            gameActive = false;
            uiManager.ShowWinScreen();
        }
    }

    void CheckGameEnd()
    {
        if (currentMoves <= 0)
        {
            bool hasGoalsComplete = true;
            foreach (var goal in currentGoals)
            {
                if (goal.currentAmount < goal.targetAmount)
                {
                    hasGoalsComplete = false;
                    break;
                }
            }

            if (!hasGoalsComplete)
            {
                gameActive = false;
                uiManager.ShowLoseScreen();
            }
        }
    }

    public void RestartLevel()
    {
        gameActive = true;
        InitializeGame();
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Cubes\CubeController.cs
================================================================================

using UnityEngine;

public class CubeController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private Collider2D cubeCollider;

    public int ColorIndex { get; private set; }
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        cubeCollider = GetComponent<Collider2D>();
    }

    public void Initialize(int colorIndex, Sprite cubeSprite)
    {
        ColorIndex = colorIndex;
        spriteRenderer.sprite = cubeSprite;

        spriteRenderer.sortingLayerName = "Default";

        spriteRenderer.color = new Color(1f, 1f, 1f, 1f);
        spriteRenderer.enabled = true;

        if (spriteRenderer.material == null || spriteRenderer.material.name.Contains("Default"))
        {
            spriteRenderer.material = new Material(Shader.Find("Sprites/Default"));
        }

        if (cubeCollider != null)
        {
            cubeCollider.enabled = true;
            cubeCollider.isTrigger = false;

            if (cubeCollider is BoxCollider2D boxCollider)
            {
                boxCollider.size = Vector2.one;
            }
        }
    }

    public void SetGridPosition(Vector2Int position)
    {
        GridPosition = position;
        gameObject.name = $"Cube_{position.x}_{position.y}_{ColorIndex}";
    }

    void OnMouseDown()
    {
        Debug.Log($"Cube clicked: {gameObject.name} at grid position {GridPosition}");

        if (GridPosition.x >= 0 && GridPosition.y >= 0)
        {
            GridManager gridManager = FindObjectOfType<GridManager>();
            if (gridManager != null)
            {
                gridManager.HandleCubeClick(GridPosition.x, GridPosition.y);
            }
            else
            {
                Debug.LogError("GridManager not found!");
            }
        }
        else
        {
            Debug.LogError($"Invalid grid position: {GridPosition}");
        }
    }

    public void AnimateCollection(Vector3 targetPosition)
    {
        StartCoroutine(AnimateToTarget(targetPosition));
    }

    private System.Collections.IEnumerator AnimateToTarget(Vector3 target)
    {
        Vector3 startPos = transform.position;
        float duration = 0.8f;
        float elapsed = 0;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / duration;
            transform.position = Vector3.Lerp(startPos, target, t);
            yield return null;
        }

        Destroy(gameObject);
    }

    void OnMouseEnter()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1.2f, 1.2f, 1.2f, 1f);
        }
    }

    void OnMouseExit()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1f, 1f, 1f, 1f);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Effects\EffectsManager.cs
================================================================================

using System.Collections;
using UnityEngine;

public class EffectsManager : MonoBehaviour
{
    [Header("Prefabs")]
    public GameObject particleSystemPrefab;

    private GameConfig config;

    void Start()
    {
        config = GameManager.Instance.gameConfig;
        CreateParticleSystemPrefab();
    }

    void CreateParticleSystemPrefab()
    {
        if (particleSystemPrefab == null && config.particleSprites.Length > 0)
        {
            GameObject prefab = new GameObject("CubeExplosionParticle");
            ParticleSystem ps = prefab.AddComponent<ParticleSystem>();

            var main = ps.main;
            main.startLifetime = config.particleLifetime;
            main.startSpeed = 5f;
            main.startSize = 0.3f;
            main.startColor = Color.white;
            main.maxParticles = 15;
            main.simulationSpace = ParticleSystemSimulationSpace.World;

            var emission = ps.emission;
            emission.rateOverTime = 0;
            emission.SetBursts(new ParticleSystem.Burst[] { new ParticleSystem.Burst(0, 10) });

            var shape = ps.shape;
            shape.enabled = true;
            shape.shapeType = ParticleSystemShapeType.Circle;
            shape.radius = 0.3f;

            var velocityOverLifetime = ps.velocityOverLifetime;
            velocityOverLifetime.enabled = true;
            velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;
            velocityOverLifetime.radial = new ParticleSystem.MinMaxCurve(2f, 4f);

            var renderer = ps.GetComponent<ParticleSystemRenderer>();
            renderer.material = new Material(Shader.Find("Sprites/Default"));

            renderer.material.mainTexture = config.particleSprites[0].texture;
            renderer.sortingLayerName = "Default";
            renderer.sortingOrder = 10;

            particleSystemPrefab = prefab;
            particleSystemPrefab.SetActive(false);
        }
    }

    public void PlayExplosionEffect(Vector3 position, int colorIndex = 0)
    {
        if (particleSystemPrefab != null)
        {
            if (float.IsNaN(position.x) || float.IsNaN(position.y) || float.IsNaN(position.z))
            {
                Debug.LogWarning("Invalid particle position detected, skipping effect");
                return;
            }

            GameObject particle = Instantiate(particleSystemPrefab, position, Quaternion.identity);
            particle.SetActive(true);

            ParticleSystem ps = particle.GetComponent<ParticleSystem>();
            if (ps != null)
            {
                var main = ps.main;

                Color particleColor = GetColorFromIndex(colorIndex);
                main.startColor = particleColor;

                var renderer = ps.GetComponent<ParticleSystemRenderer>();
                if (config.particleSprites.Length > 1)
                {
                    int randomSpriteIndex = Random.Range(0, config.particleSprites.Length);
                    renderer.material.mainTexture = config
                        .particleSprites[randomSpriteIndex]
                        .texture;
                }

                ps.Play();

                StartCoroutine(DestroyAfterDelay(particle, config.particleLifetime + 0.5f));
            }
        }
        else
        {
            Debug.LogWarning("Particle system prefab is null!");
        }
    }

    Color GetColorFromIndex(int colorIndex)
    {
        Color[] colors =
        {
            Color.yellow,
            Color.red,
            new Color(0f, 0.6f, 1f),
            Color.green,
            new Color(0.8f, 0.4f, 0.9f)
        };

        if (colorIndex >= 0 && colorIndex < colors.Length)
        {
            return colors[colorIndex];
        }

        return Color.white;
    }

    IEnumerator DestroyAfterDelay(GameObject obj, float delay)
    {
        yield return new WaitForSeconds(delay);
        if (obj != null)
        {
            Destroy(obj);
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridCell.cs
================================================================================

using UnityEngine;

[System.Serializable]
public class GridCell
{
    public Vector2Int position;
    public CubeController cube;
    public RocketController rocket;

    public DuckController duck;

    public BalloonController balloon;

    public bool isEmpty => cube == null && rocket == null && duck == null && balloon == null;
    public bool hasCube => cube != null;
    public bool hasRocket => rocket != null;
    public bool hasDuck => duck != null;
    public bool hasBalloon => balloon != null;

    public GridCell(int x, int y)
    {
        position = new Vector2Int(x, y);
        cube = null;
        rocket = null;

        duck = null;

        balloon = null;
    }

    public void SetCube(CubeController newCube)
    {
        cube = newCube;
        rocket = null;
        duck = null;
        if (cube != null)
        {
            cube.SetGridPosition(position);
        }
    }

    public void SetRocket(RocketController newRocket)
    {
        rocket = newRocket;
        cube = null;
        duck = null;
        if (rocket != null)
        {
            rocket.SetGridPosition(position);
        }
    }

    public void SetBalloon(BalloonController newBalloon)
    {
        Clear();
        balloon = newBalloon;
        if (balloon != null)
        {
            balloon.SetGridPosition(position);
        }
    }

    public void SetDuck(DuckController newDuck)
    {
        duck = newDuck;
        cube = null;
        rocket = null;
        if (duck != null)
        {
            duck.SetGridPosition(position);
        }
    }

    public void ClearCube()
    {
        if (cube != null)
        {
            cube.SetGridPosition(new Vector2Int(-1, -1));
        }
        cube = null;
    }

    public void ClearRocket()
    {
        rocket = null;
    }

    public void ClearBalloon()
    {
        balloon = null;
    }

    public void ClearDuck()
    {
        duck = null;
    }

    public void Clear()
    {
        ClearCube();
        ClearRocket();

        ClearDuck();
        ClearBalloon();
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridManager.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GridManager : MonoBehaviour
{
    [Header("Grid Setup")]
    public Transform gridParent;
    public GameObject cubePrefab;

    public GameObject duckPrefab;

    public GameObject balloonPrefab;

    private GridCell[,] grid;
    private GameConfig config;
    private Camera mainCamera;
    private bool isProcessingMatches = false;

    public int Width => config.gridWidth;
    public int Height => config.gridHeight;
    private const float VerticalOverlapFactor = 1f;

    void Awake()
    {
        mainCamera = Camera.main;

        if (cubePrefab == null)
        {
            CreateCubePrefab();
        }

        if (balloonPrefab == null)
            CreateBalloonPrefab();

        if (duckPrefab == null)
        {
            CreateDuckPrefab();
        }
    }

    void CreateCubePrefab()
    {
        cubePrefab = new GameObject("CubePrefab");
        SpriteRenderer sr = cubePrefab.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 0;
        sr.color = new Color(1f, 1f, 1f, 1f);
        sr.material = new Material(Shader.Find("Sprites/Default"));
        BoxCollider2D collider = cubePrefab.AddComponent<BoxCollider2D>();
        collider.size = Vector2.one;
        cubePrefab.AddComponent<CubeController>();
        cubePrefab.SetActive(false);
        DontDestroyOnLoad(cubePrefab);
    }

    void CreateDuckPrefab()
    {
        duckPrefab = new GameObject("DuckPrefab");
        SpriteRenderer sr = duckPrefab.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 5;
        sr.color = Color.white;
        duckPrefab.AddComponent<DuckController>();
        duckPrefab.SetActive(false);
        DontDestroyOnLoad(duckPrefab);
    }

    void CreateBalloonPrefab()
    {
        balloonPrefab = new GameObject("BalloonPrefab");
        SpriteRenderer sr = balloonPrefab.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 5;
        balloonPrefab.AddComponent<BalloonController>();
        balloonPrefab.SetActive(false);
        DontDestroyOnLoad(balloonPrefab);
    }

    public void InitializeGrid()
    {
        config = GameManager.Instance.gameConfig;
        if (config == null)
        {
            Debug.LogError("GameConfig is null!");
            return;
        }

        if (gridParent != null)
        {
            foreach (Transform child in gridParent)
            {
                if (Application.isPlaying)
                    Destroy(child.gameObject);
                else
                    DestroyImmediate(child.gameObject);
            }
        }

        isProcessingMatches = false;
        grid = new GridCell[Width, Height];
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                grid[x, y] = new GridCell(x, y);
            }
        }

        SetupCameraAndGrid();
        FillInitialGrid();

        SpawnInitialDucks();

        SpawnInitialBalloons();

        CheckAndCollectBottomRowDucks();
    }

    void SetupCameraAndGrid()
    {
        float totalWidth = Width * config.cellSize + (Width - 1) * config.gridSpacing;
        float verticalStep = config.cellSize * VerticalOverlapFactor;
        float totalHeight = ((Height - 1) * verticalStep) + config.cellSize;
        Vector3 gridOffset = new Vector3(
            -totalWidth * 0.5f + config.cellSize * 0.5f,
            -totalHeight * 0.5f + config.cellSize * 0.5f,
            0
        );

        if (gridParent != null)
        {
            gridParent.position = gridOffset;
        }
        float requiredSize = Mathf.Max(totalHeight * 0.7f, totalWidth * 0.6f / mainCamera.aspect);
        mainCamera.orthographicSize = requiredSize;
        mainCamera.transform.position = new Vector3(0, 0, -10f);
    }

    void FillInitialGrid()
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                CreateRandomCube(x, y);
            }
        }
    }

    void SpawnInitialDucks()
    {
        int ducksToPlace = config.ducksInLevel;
        if (ducksToPlace <= 0)
            return;

        List<Vector2Int> availableCells = new List<Vector2Int>();
        // Prevent spawning in bottom row (y = 0) by starting from y = 1
        for (int x = 0; x < Width; x++)
        {
            for (int y = 1; y < Height; y++) // Start from y = 1, not y = 0
            {
                if (grid[x, y].isEmpty || grid[x, y].hasCube)
                {
                    availableCells.Add(new Vector2Int(x, y));
                }
            }
        }

        for (int i = 0; i < ducksToPlace; i++)
        {
            if (availableCells.Count == 0)
            {
                Debug.LogWarning("Not enough available cells to place all ducks.");
                break;
            }

            int randomIndex = Random.Range(0, availableCells.Count);
            Vector2Int cellPos = availableCells[randomIndex];
            availableCells.RemoveAt(randomIndex);

            if (grid[cellPos.x, cellPos.y].hasCube)
            {
                Destroy(grid[cellPos.x, cellPos.y].cube.gameObject);
                grid[cellPos.x, cellPos.y].ClearCube();
            }

            DuckController newDuck = CreateDuck(cellPos.x, cellPos.y);
        }
    }

    DuckController CreateDuck(int x, int y)
    {
        if (duckPrefab == null)
        {
            Debug.LogError("DuckPrefab is not set!");
            return null;
        }
        GameObject duckObj = Instantiate(duckPrefab, gridParent);
        duckObj.SetActive(true);

        SpriteRenderer sr = duckObj.GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            sr.sortingOrder = y;
        }

        DuckController duck = duckObj.GetComponent<DuckController>();
        duck.Initialize(new Vector2Int(x, y));

        Vector3 worldPos = GridToWorldPosition(x, y);
        duck.transform.position = worldPos;

        grid[x, y].SetDuck(duck);

        return duck;
    }

    void CreateRandomCube(int x, int y)
    {
        if (cubePrefab == null || config.cubeSprites == null || config.cubeSprites.Length == 0)
        {
            Debug.LogError("Cannot create cube - missing prefab or sprites!");
            return;
        }

        GameObject cubeObj = Instantiate(cubePrefab, gridParent);
        cubeObj.SetActive(true);
        cubeObj.name = $"Cube_{x}_{y}";

        CubeController cube = cubeObj.GetComponent<CubeController>();
        if (cube == null)
        {
            Debug.LogError("CubePrefab doesn't have CubeController component!");
            return;
        }

        SpriteRenderer sr = cubeObj.GetComponent<SpriteRenderer>();
        if (sr != null)
        {
            sr.sortingOrder = y;
        }

        int randomColorIndex = Random.Range(0, config.cubeSprites.Length);
        cube.Initialize(randomColorIndex, config.cubeSprites[randomColorIndex]);

        Vector3 worldPos = GridToWorldPosition(x, y);
        cube.transform.position = worldPos;

        cube.SetGridPosition(new Vector2Int(x, y));
        grid[x, y].SetCube(cube);
    }

    public Vector3 GridToWorldPosition(int x, int y)
    {
        float worldX = x * (config.cellSize + config.gridSpacing);
        float worldY = y * (config.cellSize * VerticalOverlapFactor);
        return gridParent.position + new Vector3(worldX, worldY, 0);
    }

    public Vector2Int WorldToGridPosition(Vector3 worldPos)
    {
        Vector3 localPos = worldPos - gridParent.position;
        int x = Mathf.RoundToInt(localPos.x / (config.cellSize + config.gridSpacing));
        int y = Mathf.RoundToInt(localPos.y / (config.cellSize * VerticalOverlapFactor));
        return new Vector2Int(x, y);
    }

    public GridCell GetCell(int x, int y)
    {
        if (x >= 0 && x < Width && y >= 0 && y < Height)
            return grid[x, y];
        return null;
    }

    public List<GridCell> FindMatches(int x, int y)
    {
        GridCell startCell = GetCell(x, y);
        if (startCell == null || !startCell.hasCube)
            return new List<GridCell>();

        List<GridCell> matches = new List<GridCell>();
        HashSet<Vector2Int> visited = new HashSet<Vector2Int>();

        FloodFillMatches(x, y, startCell.cube.ColorIndex, matches, visited);

        return matches.Count >= config.minMatchSize ? matches : new List<GridCell>();
    }

    void FloodFillMatches(
        int x,
        int y,
        int targetColor,
        List<GridCell> matches,
        HashSet<Vector2Int> visited
    )
    {
        if (visited.Contains(new Vector2Int(x, y)))
            return;

        GridCell cell = GetCell(x, y);
        if (cell == null || !cell.hasCube || cell.cube.ColorIndex != targetColor)
            return;

        visited.Add(new Vector2Int(x, y));
        matches.Add(cell);

        FloodFillMatches(x + 1, y, targetColor, matches, visited);
        FloodFillMatches(x - 1, y, targetColor, matches, visited);
        FloodFillMatches(x, y + 1, targetColor, matches, visited);
        FloodFillMatches(x, y - 1, targetColor, matches, visited);
    }

    public void HandleCubeClick(int x, int y)
    {
        if (!GameManager.Instance.gameActive || isProcessingMatches)
        {
            Debug.Log(
                $"Click ignored - Game active: {GameManager.Instance.gameActive}, Processing: {isProcessingMatches}"
            );
            return;
        }

        GridCell clickedCell = GetCell(x, y);
        if (clickedCell == null)
            return;

        if (clickedCell.hasRocket)
        {
            if (GameManager.Instance.TryMakeMove())
            {
                StartCoroutine(ProcessRocketActivation(clickedCell));
            }
            return;
        }

        if (clickedCell.hasCube)
        {
            List<GridCell> matches = FindMatches(x, y);
            if (matches.Count > 0)
            {
                if (GameManager.Instance.TryMakeMove())
                {
                    StartCoroutine(ProcessMatches(matches, new Vector2Int(x, y)));
                }
            }
        }
    }

    private IEnumerator ProcessRocketActivation(GridCell rocketCell)
    {
        isProcessingMatches = true;

        RocketController rocket = rocketCell.rocket;
        Vector2Int rocketGridPos = rocket.GridPosition;

        rocketCell.ClearRocket();

        Vector3 targetPosition;
        if (rocket.direction == RocketController.RocketDirection.Horizontal)
        {
            targetPosition = GridToWorldPosition(-1, rocketGridPos.y);
        }
        else
        {
            targetPosition = GridToWorldPosition(rocketGridPos.x, Height);
        }

        yield return StartCoroutine(rocket.AnimateTravel(targetPosition));

        List<GridCell> cellsToDestroy = new List<GridCell>();
        if (rocket.direction == RocketController.RocketDirection.Horizontal)
        {
            for (int ix = 0; ix < Width; ix++)
            {
                cellsToDestroy.Add(GetCell(ix, rocketGridPos.y));
            }
        }
        else
        {
            for (int iy = 0; iy < Height; iy++)
            {
                cellsToDestroy.Add(GetCell(rocketGridPos.x, iy));
            }
        }

        foreach (var cell in cellsToDestroy)
        {
            if (cell == null)
                continue;

            if (cell.hasCube)
            {
                GameManager.Instance.CollectCube(cell.cube.ColorIndex, 1);
                GameManager.Instance.effectsManager.PlayExplosionEffect(
                    cell.cube.transform.position,
                    cell.cube.ColorIndex
                );
                Destroy(cell.cube.gameObject);
                cell.ClearCube();
            }
            if (cell.hasRocket)
            {
                GameManager.Instance.effectsManager.PlayExplosionEffect(
                    cell.rocket.transform.position
                );
                Destroy(cell.rocket.gameObject);
                cell.ClearRocket();
            }
        }

        GameManager.Instance.audioManager.PlayExplosionSound();
        yield return new WaitForSeconds(config.explosionDuration);

        yield return StartCoroutine(ApplyGravity());
        yield return StartCoroutine(FillEmptySpaces());
        CheckAndCollectBottomRowDucks();

        UpdateAllObjectPositions();

        isProcessingMatches = false;
    }

    void SpawnInitialBalloons()
    {
        int balloonsToPlace = config.balloonsInLevel;
        if (balloonsToPlace <= 0)
            return;

        List<Vector2Int> availableCells = new List<Vector2Int>();
        for (int x = 0; x < Width; x++)
        {
            for (int y = Height / 2; y < Height; y++)
            {
                if (grid[x, y].isEmpty || grid[x, y].hasCube)
                {
                    availableCells.Add(new Vector2Int(x, y));
                }
            }
        }

        for (int i = 0; i < balloonsToPlace; i++)
        {
            if (availableCells.Count == 0)
                break;

            int randomIndex = Random.Range(0, availableCells.Count);
            Vector2Int cellPos = availableCells[randomIndex];
            availableCells.RemoveAt(randomIndex);

            if (grid[cellPos.x, cellPos.y].hasCube)
            {
                Destroy(grid[cellPos.x, cellPos.y].cube.gameObject);
                grid[cellPos.x, cellPos.y].ClearCube();
            }
            CreateBalloon(cellPos.x, cellPos.y);
        }
    }

    private void CheckAndCollectBottomRowDucks()
    {
        for (int x = 0; x < Width; x++)
        {
            GridCell cell = grid[x, 0]; // Bottom row is y = 0
            if (cell != null && cell.hasDuck && cell.duck != null)
            {
                // Collect the duck immediately
                DuckController duck = cell.duck;
                cell.ClearDuck(); // Clear from grid first to prevent double collection
                duck.CollectDuck();
            }
        }
    }

    void CreateBalloon(int x, int y)
    {
        if (balloonPrefab == null)
            return;

        GameObject balloonObj = Instantiate(balloonPrefab, gridParent);
        balloonObj.SetActive(true);

        SpriteRenderer sr = balloonObj.GetComponent<SpriteRenderer>();
        if (sr != null)
            sr.sortingOrder = y;

        BalloonController balloon = balloonObj.GetComponent<BalloonController>();
        balloon.Initialize(new Vector2Int(x, y));
        balloon.transform.position = GridToWorldPosition(x, y);
        grid[x, y].SetBalloon(balloon);
    }

    IEnumerator ProcessMatches(List<GridCell> matches, Vector2Int clickPosition)
    {
        isProcessingMatches = true;

        int colorIndex = matches[0].cube.ColorIndex;
        GameManager.Instance.CollectCube(colorIndex, matches.Count);

        bool shouldCreateRocket = matches.Count >= config.rocketTriggerSize;
        Vector3 rocketWorldPosition = GridToWorldPosition(clickPosition.x, clickPosition.y);

        List<GridCell> adjacentBalloons = new List<GridCell>();

        foreach (var matchCell in matches)
        {
            Vector2Int[] adjacentPositions =
            {
                new Vector2Int(matchCell.position.x + 1, matchCell.position.y),
                new Vector2Int(matchCell.position.x - 1, matchCell.position.y),
                new Vector2Int(matchCell.position.x, matchCell.position.y + 1),
                new Vector2Int(matchCell.position.x, matchCell.position.y - 1)
            };

            foreach (var pos in adjacentPositions)
            {
                GridCell adjacentCell = GetCell(pos.x, pos.y);
                if (
                    adjacentCell != null
                    && adjacentCell.hasBalloon
                    && !adjacentBalloons.Contains(adjacentCell)
                )
                {
                    adjacentBalloons.Add(adjacentCell);
                }
            }
        }
        foreach (var cell in matches)
        {
            if (cell.cube != null)
            {
                Vector3 explosionPosition = cell.cube.transform.position;
                if (!float.IsNaN(explosionPosition.x) && !float.IsNaN(explosionPosition.y))
                {
                    GameManager.Instance.effectsManager.PlayExplosionEffect(
                        explosionPosition,
                        cell.cube.ColorIndex
                    );
                }
                Destroy(cell.cube.gameObject);
                cell.ClearCube();
            }
        }

        foreach (var balloonCell in adjacentBalloons)
        {
            if (balloonCell.balloon != null)
            {
                balloonCell.balloon.Explode();
                balloonCell.ClearBalloon();
            }
        }

        GameManager.Instance.audioManager.PlayExplosionSound();
        yield return new WaitForSeconds(config.explosionDuration);

        if (shouldCreateRocket)
        {
            CreateRocket(clickPosition, rocketWorldPosition);
        }

        yield return StartCoroutine(ApplyGravity());
        yield return StartCoroutine(FillEmptySpaces());

        CheckAndCollectBottomRowDucks();

        UpdateAllObjectPositions();

        isProcessingMatches = false;
    }

    void CreateRocket(Vector2Int gridPosition, Vector3 worldPosition)
    {
        RocketController.RocketDirection direction =
            Random.Range(0, 2) == 0
                ? RocketController.RocketDirection.Horizontal
                : RocketController.RocketDirection.Vertical;

        GameObject rocketObj = new GameObject("Rocket");
        rocketObj.transform.SetParent(gridParent);

        SpriteRenderer sr = rocketObj.AddComponent<SpriteRenderer>();
        sr.sortingLayerName = "Default";
        sr.sortingOrder = 6;

        BoxCollider2D col = rocketObj.AddComponent<BoxCollider2D>();
        col.size = Vector2.one;

        RocketController rocket = rocketObj.AddComponent<RocketController>();
        rocket.Initialize(direction, gridPosition);
        rocketObj.transform.position = worldPosition;

        GridCell cell = GetCell(gridPosition.x, gridPosition.y);
        if (cell != null)
        {
            cell.SetRocket(rocket);
        }
    }

    void UpdateAllObjectPositions()
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                GridCell cell = grid[x, y];
                Vector3 correctPosition = GridToWorldPosition(x, y);

                if (cell.hasCube && cell.cube != null)
                {
                    cell.cube.SetGridPosition(new Vector2Int(x, y));
                    cell.cube.transform.position = correctPosition;
                }

                if (cell.hasBalloon && cell.balloon != null)
                {
                    cell.balloon.SetGridPosition(new Vector2Int(x, y));
                    cell.balloon.transform.position = correctPosition;
                }
                if (cell.hasRocket && cell.rocket != null)
                {
                    cell.rocket.SetGridPosition(new Vector2Int(x, y));
                    cell.rocket.transform.position = correctPosition;
                }

                if (cell.hasDuck && cell.duck != null)
                {
                    cell.duck.SetGridPosition(new Vector2Int(x, y));
                    cell.duck.transform.position = correctPosition;
                }
            }
        }
    }

    IEnumerator ApplyGravity()
    {
        bool itemsMoved = true;
        while (itemsMoved)
        {
            itemsMoved = false;
            for (int x = 0; x < Width; x++)
            {
                for (int y = 0; y < Height - 1; y++)
                {
                    GridCell currentCell = grid[x, y];

                    if (!currentCell.isEmpty)
                        continue;

                    for (int yAbove = y + 1; yAbove < Height; yAbove++)
                    {
                        GridCell aboveCell = grid[x, yAbove];

                        if (aboveCell.hasDuck)
                        {
                            DuckController duckToMove = aboveCell.duck;
                            currentCell.SetDuck(duckToMove);
                            aboveCell.ClearDuck();

                            SpriteRenderer sr = duckToMove.GetComponent<SpriteRenderer>();
                            if (sr != null)
                                sr.sortingOrder = y;

                            StartCoroutine(
                                AnimateObjectFall(duckToMove.transform, GridToWorldPosition(x, y))
                            );
                            itemsMoved = true;

                            break;
                        }

                        if (aboveCell.hasBalloon)
                        {
                            BalloonController balloonToMove = aboveCell.balloon;
                            currentCell.SetBalloon(balloonToMove);
                            aboveCell.ClearBalloon();

                            SpriteRenderer sr = balloonToMove.GetComponent<SpriteRenderer>();
                            if (sr != null)
                                sr.sortingOrder = y;

                            StartCoroutine(
                                AnimateObjectFall(
                                    balloonToMove.transform,
                                    GridToWorldPosition(x, y)
                                )
                            );
                            itemsMoved = true;
                            break;
                        }

                        if (aboveCell.hasCube)
                        {
                            CubeController cubeToMove = aboveCell.cube;
                            currentCell.SetCube(cubeToMove);
                            aboveCell.ClearCube();

                            SpriteRenderer sr = cubeToMove.GetComponent<SpriteRenderer>();
                            if (sr != null)
                                sr.sortingOrder = y;

                            StartCoroutine(
                                AnimateObjectFall(cubeToMove.transform, GridToWorldPosition(x, y))
                            );
                            itemsMoved = true;
                            break;
                        }
                    }
                }
            }
            if (itemsMoved)
            {
                yield return new WaitForSeconds(0.1f);
            }
        }
    }

    IEnumerator FillEmptySpaces()
    {
        for (int x = 0; x < Width; x++)
        {
            for (int y = Height - 1; y >= 0; y--)
            {
                GridCell cell = grid[x, y];

                if (cell.isEmpty)
                {
                    CreateRandomCube(x, y);

                    if (cell.hasCube && cell.cube != null)
                    {
                        Vector3 startPos = GridToWorldPosition(x, Height);
                        Vector3 endPos = GridToWorldPosition(x, y);
                        cell.cube.transform.position = startPos;
                        StartCoroutine(AnimateObjectFall(cell.cube.transform, endPos));
                    }
                }
            }
        }
        yield return new WaitForSeconds(config.cubeFallSpeed / 5f);
    }

    IEnumerator AnimateObjectFall(Transform objTransform, Vector3 targetPosition)
    {
        if (objTransform == null)
            yield break;

        Vector3 startPosition = objTransform.position;
        float journey = 0f;
        float speed = config.cubeFallSpeed;

        while (journey <= 1f && objTransform != null)
        {
            journey += Time.deltaTime * speed;
            objTransform.position = Vector3.Lerp(startPosition, targetPosition, journey);
            yield return null;
        }

        if (objTransform != null)
        {
            objTransform.position = targetPosition;
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\Grid\GridPosition.cs
================================================================================

[System.Serializable]
public struct GridPosition
{
    public int x;
    public int y;

    public GridPosition(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static GridPosition operator +(GridPosition a, GridPosition b)
    {
        return new GridPosition(a.x + b.x, a.y + b.y);
    }

    public static bool operator ==(GridPosition a, GridPosition b)
    {
        return a.x == b.x && a.y == b.y;
    }

    public static bool operator !=(GridPosition a, GridPosition b)
    {
        return !(a == b);
    }

    public override bool Equals(object obj)
    {
        if (obj is GridPosition)
            return this == (GridPosition)obj;
        return false;
    }

    public override int GetHashCode()
    {
        return x.GetHashCode() ^ y.GetHashCode();
    }

    public GridPosition[] GetAdjacent()
    {
        return new GridPosition[]
        {
            new GridPosition(x, y + 1),
            new GridPosition(x, y - 1),
            new GridPosition(x - 1, y),
            new GridPosition(x + 1, y)
        };
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\BalloonController.cs
================================================================================

using UnityEngine;

public class BalloonController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
    }

    public void Initialize(Vector2Int gridPos)
    {
        GridPosition = gridPos;
        if (GameManager.Instance != null && GameManager.Instance.gameConfig != null)
        {
            spriteRenderer.sprite = GameManager.Instance.gameConfig.balloonSprite;
        }
        gameObject.name = $"Balloon_{gridPos.x}_{gridPos.y}";
    }

    public void SetGridPosition(Vector2Int newPos)
    {
        GridPosition = newPos;
        gameObject.name = $"Balloon_{newPos.x}_{newPos.y}";
    }

    public void Explode()
    {
        GameManager.Instance.CollectBalloon();

        GameManager.Instance.audioManager.PlayBalloonSound();
        GameManager.Instance.effectsManager.PlayExplosionEffect(transform.position);

        Destroy(gameObject);
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\DuckController.cs
================================================================================

using UnityEngine;

public class DuckController : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private GridManager gridManager;
    private bool isCollected = false;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        gridManager = FindObjectOfType<GridManager>();
    }

    public void Initialize(Vector2Int gridPos)
    {
        GridPosition = gridPos;
        spriteRenderer.sprite = GameManager.Instance.gameConfig.duckSprite;
        transform.position = gridManager.GridToWorldPosition(gridPos.x, gridPos.y);
        gameObject.name = $"Duck_{gridPos.x}_{gridPos.y}";
        isCollected = false;
    }

    public void CollectDuck()
    {
        if (isCollected || this == null || gameObject == null)
            return;

        isCollected = true;

        GameManager.Instance.audioManager.PlayDuckSound();
        GameManager.Instance.CollectDuck();
        GameManager.Instance.effectsManager.PlayExplosionEffect(transform.position);

        if (Application.isPlaying)
        {
            Destroy(gameObject);
        }
        else
        {
            DestroyImmediate(gameObject);
        }
    }

    public void SetGridPosition(Vector2Int newPos)
    {
        GridPosition = newPos;
        gameObject.name = $"Duck_{newPos.x}_{newPos.y}";
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\SpecialObjects\RocketController.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RocketController : MonoBehaviour
{
    public enum RocketDirection
    {
        Horizontal,
        Vertical
    }

    [Header("Rocket Settings")]
    public RocketDirection direction;

    private SpriteRenderer spriteRenderer;
    private Collider2D rocketCollider;
    private GridManager gridManager;
    private GameConfig config;
    public Vector2Int GridPosition { get; private set; }

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        rocketCollider = GetComponent<Collider2D>();
        gridManager = FindObjectOfType<GridManager>();
        config = GameManager.Instance.gameConfig;
    }

    public void Initialize(RocketDirection dir, Vector2Int gridPos)
    {
        direction = dir;
        GridPosition = gridPos;

        if (direction == RocketDirection.Horizontal)
        {
            spriteRenderer.sprite = config.rocketHorizontalSprite;
        }
        else
        {
            spriteRenderer.sprite = config.rocketVerticalSprite;
        }

        spriteRenderer.sortingLayerName = "Default";
        spriteRenderer.sortingOrder = 6;
        spriteRenderer.color = Color.white;

        if (rocketCollider != null)
        {
            rocketCollider.enabled = true;
            rocketCollider.isTrigger = false;

            if (rocketCollider is BoxCollider2D boxCollider)
            {
                boxCollider.size = Vector2.one;
            }
        }

        gameObject.name = $"Rocket_{direction}_{gridPos.x}_{gridPos.y}";

        Debug.Log($"Rocket initialized: {direction} at {gridPos}");
    }

    public void SetGridPosition(Vector2Int position)
    {
        GridPosition = position;
    }

    void OnMouseDown()
    {
        Debug.Log($"Rocket clicked: {gameObject.name} at {GridPosition}");

        if (gridManager != null)
        {
            gridManager.HandleCubeClick(GridPosition.x, GridPosition.y);
        }
    }

    public IEnumerator AnimateTravel(Vector3 targetPosition)
    {
        if (rocketCollider != null)
        {
            rocketCollider.enabled = false;
        }

        Vector3 startPosition = transform.position;
        float distance = Vector3.Distance(startPosition, targetPosition);

        if (config.rocketMoveSpeed <= 0)
        {
            Debug.LogWarning("Rocket move speed is zero or less. Snapping to target.");
            transform.position = targetPosition;
            Destroy(gameObject);
            yield break;
        }

        float duration = distance / config.rocketMoveSpeed;
        float elapsed = 0f;

        while (elapsed < duration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.position = targetPosition;
        Destroy(gameObject);
    }

    void OnMouseEnter()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = new Color(1.2f, 1.2f, 1.2f, 1f);
        }
    }

    void OnMouseExit()
    {
        if (spriteRenderer != null)
        {
            spriteRenderer.color = Color.white;
        }
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\UI\GoalUIItem.cs
================================================================================

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class GoalUIItem : MonoBehaviour
{
    [Header("UI References")]
    public Image goalIcon;
    public TextMeshProUGUI goalTextTMP;

    private LevelGoal currentGoal;

    public void Initialize(LevelGoal goal, Sprite cubeSprite)
    {
        currentGoal = new LevelGoal
        {
            colorIndex = goal.colorIndex,
            targetAmount = goal.targetAmount,
            currentAmount = 0
        };

        if (goalIcon)
            goalIcon.sprite = cubeSprite;

        UpdateDisplay();
    }

    public void UpdateGoal(LevelGoal goal)
    {
        int oldAmount = currentGoal != null ? currentGoal.currentAmount : 0;
        currentGoal = goal;
        UpdateDisplay();

        if (goal.currentAmount > oldAmount)
        {
            AnimateGoalCollection();
        }
    }

    void UpdateDisplay()
    {
        if (currentGoal == null)
            return;

        int remainingAmount = currentGoal.targetAmount - currentGoal.currentAmount;
        if (remainingAmount < 0)
            remainingAmount = 0;

        if (goalTextTMP != null)
        {
            goalTextTMP.text = remainingAmount.ToString();
        }

        if (remainingAmount <= 0)
        {
            goalTextTMP.gameObject.SetActive(false);

            if (goalIcon)
                goalIcon.color = Color.gray;
        }
    }

    void AnimateGoalCollection()
    {
        StartCoroutine(ScaleAnimation());
    }

    System.Collections.IEnumerator ScaleAnimation()
    {
        Vector3 originalScale = transform.localScale;
        Vector3 targetScale = originalScale * 1.2f;
        float duration = 0.1f;

        for (float t = 0; t < 1; t += Time.deltaTime / duration)
        {
            transform.localScale = Vector3.Lerp(originalScale, targetScale, t);
            yield return null;
        }

        for (float t = 0; t < 1; t += Time.deltaTime / duration)
        {
            transform.localScale = Vector3.Lerp(targetScale, originalScale, t);
            yield return null;
        }

        transform.localScale = originalScale;
    }
}


================================================================================
FILE: F:\Unity\Match2Game\Assets\Scripts\UI\UIManager.cs
================================================================================

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIManager : MonoBehaviour
{
    [Header("UI References")]
    public TextMeshProUGUI movesTextTMP;
    public Transform goalsContainer;
    public GameObject winPanel;
    public GameObject losePanel;
    public Button restartButton;

    [Header("Font Settings")]
    public Font defaultFont;

    private List<GoalUIItem> goalUIItems = new List<GoalUIItem>();
    private GameConfig config;

    void Start()
    {
        config = GameManager.Instance.gameConfig;

        if (defaultFont == null)
        {
            defaultFont = Resources.GetBuiltinResource<Font>("Arial.ttf");
        }

        if (winPanel)
            winPanel.SetActive(false);
        if (losePanel)
            losePanel.SetActive(false);

        SetupMovesText();
        SetupGoalUI();
        SetupPanels();
    }

    void SetupMovesText()
    {
        if (movesTextTMP != null)
        {
            RectTransform movesRect = movesTextTMP.GetComponent<RectTransform>();

            movesRect.anchorMin = new Vector2(1, 1);
            movesRect.anchorMax = new Vector2(1, 1);
            movesRect.pivot = new Vector2(1, 1);
            movesRect.anchoredPosition = new Vector2(-60, -60);
            movesRect.sizeDelta = new Vector2(150, 100);

            movesTextTMP.text = "" + GameManager.Instance.currentMoves;
            movesTextTMP.fontSize = 90;
            movesTextTMP.color = new Color32(198, 68, 60, 255);
            movesTextTMP.alignment = TextAlignmentOptions.Center;
            movesTextTMP.fontStyle = FontStyles.Bold;
            movesTextTMP.outlineWidth = 0.25f;
            movesTextTMP.outlineColor = new Color32(255, 243, 224, 255);
        }
    }

    void SetupGoalUI()
    {
        RectTransform goalsRect = goalsContainer.GetComponent<RectTransform>();
        if (goalsRect != null)
        {
            goalsRect.anchorMin = new Vector2(0.5f, 1);
            goalsRect.anchorMax = new Vector2(0.5f, 1);
            goalsRect.pivot = new Vector2(0.5f, 1);
            goalsRect.anchoredPosition = new Vector2(50, -55);
            goalsRect.sizeDelta = new Vector2(350, 120);
        }

        foreach (Transform child in goalsContainer)
        {
            Destroy(child.gameObject);
        }
        goalUIItems.Clear();

        HorizontalLayoutGroup layoutGroup = goalsContainer.GetComponent<HorizontalLayoutGroup>();
        if (layoutGroup == null)
        {
            layoutGroup = goalsContainer.gameObject.AddComponent<HorizontalLayoutGroup>();
        }

        layoutGroup.childAlignment = TextAnchor.MiddleCenter;
        layoutGroup.spacing = 25;
        layoutGroup.padding = new RectOffset(10, 10, 10, 10);
        layoutGroup.childControlWidth = false;
        layoutGroup.childControlHeight = false;

        if (config.levelGoals == null)
            return;

        foreach (var goal in config.levelGoals)
        {
            GameObject goalItemObj = CreateGoalItem(goal);
            goalUIItems.Add(goalItemObj.GetComponent<GoalUIItem>());
        }

        int goalCount = config.levelGoals.Length;
        if (goalCount > 3)
        {
            float containerWidth = goalsRect.sizeDelta.x;
            float horizontalPadding = layoutGroup.padding.left + layoutGroup.padding.right;
            float totalSpacing = layoutGroup.spacing * (goalCount - 1);
            float availableWidth = containerWidth - horizontalPadding - totalSpacing;
            float newSize = 75f;

            float maxAllowedSize =
                goalsRect.sizeDelta.y - (layoutGroup.padding.top + layoutGroup.padding.bottom);
            newSize = Mathf.Min(newSize, maxAllowedSize);

            foreach (var goalItem in goalUIItems)
            {
                RectTransform itemRect = goalItem.GetComponent<RectTransform>();
                if (itemRect != null)
                {
                    itemRect.sizeDelta = new Vector2(newSize, newSize);
                }
            }
        }
    }

    GameObject CreateGoalItem(LevelGoal goal)
    {
        GameObject goalItem = new GameObject($"GoalItem_{goal.goalType}");
        goalItem.transform.SetParent(goalsContainer, false);
        goalItem.AddComponent<RectTransform>().sizeDelta = new Vector2(110, 110);

        GameObject iconObj = new GameObject("Icon");
        iconObj.transform.SetParent(goalItem.transform, false);
        Image iconImage = iconObj.AddComponent<Image>();

        Sprite goalSprite = null;
        switch (goal.goalType)
        {
            case GoalType.Cube:
                if (goal.colorIndex < config.cubeSprites.Length)
                {
                    goalSprite = config.cubeSprites[goal.colorIndex];
                }
                break;
            case GoalType.Duck:
                goalSprite = config.duckSprite;
                break;
            case GoalType.Balloon:
                goalSprite = config.balloonSprite;
                break;
        }
        iconImage.sprite = goalSprite;

        iconImage.rectTransform.sizeDelta = new Vector2(110, 110);
        iconImage.rectTransform.anchoredPosition = Vector2.zero;

        GameObject textObj = new GameObject("Text (TMP)");
        textObj.transform.SetParent(goalItem.transform, false);
        TextMeshProUGUI tmpText = textObj.AddComponent<TextMeshProUGUI>();

        tmpText.text = goal.targetAmount.ToString();
        tmpText.fontSize = 52;
        tmpText.color = new Color32(0, 0, 0, 255);
        tmpText.fontStyle = FontStyles.Bold;
        tmpText.outlineWidth = 0.2f;
        tmpText.outlineColor = new Color32(255, 243, 224, 255);

        RectTransform textRect = textObj.GetComponent<RectTransform>();
        textRect.anchorMin = new Vector2(1, 0);
        textRect.anchorMax = new Vector2(1, 0);
        textRect.pivot = new Vector2(1, 0);
        textRect.sizeDelta = new Vector2(80, 50);
        textRect.anchoredPosition = new Vector2(-5, 5);
        tmpText.alignment = TextAlignmentOptions.Center;

        GoalUIItem goalUIComponent = goalItem.AddComponent<GoalUIItem>();
        goalUIComponent.goalIcon = iconImage;
        goalUIComponent.goalTextTMP = tmpText;

        goalUIComponent.Initialize(goal, goalSprite);

        return goalItem;
    }

    void SetupPanels()
    {
        if (restartButton != null)
        {
            restartButton.onClick.RemoveAllListeners();
            restartButton.onClick.AddListener(RestartGame);
        }
        else if (winPanel != null && losePanel != null)
        {
            Button winRestartButton = winPanel.GetComponentInChildren<Button>();
            if (winRestartButton)
                winRestartButton.onClick.AddListener(RestartGame);

            Button loseRestartButton = losePanel.GetComponentInChildren<Button>();
            if (loseRestartButton)
                loseRestartButton.onClick.AddListener(RestartGame);
        }
    }

    public void UpdateUI()
    {
        UpdateMoves(GameManager.Instance.currentMoves);
        UpdateGoals(GameManager.Instance.currentGoals);
    }

    public void UpdateMoves(int moves)
    {
        if (movesTextTMP != null)
            movesTextTMP.text = moves.ToString();
    }

    public void UpdateGoals(List<LevelGoal> goals)
    {
        for (int i = 0; i < goalUIItems.Count && i < goals.Count; i++)
        {
            goalUIItems[i].UpdateGoal(goals[i]);
        }
    }

    public void ShowWinScreen()
    {
        if (winPanel)
            winPanel.SetActive(true);
    }

    public void ShowLoseScreen()
    {
        if (losePanel)
            losePanel.SetActive(true);
    }

    public void HideGameOverPanels()
    {
        if (winPanel)
            winPanel.SetActive(false);
        if (losePanel)
            losePanel.SetActive(false);
    }

    void RestartGame()
    {
        GameManager.Instance.RestartLevel();
        HideGameOverPanels();
    }
}


